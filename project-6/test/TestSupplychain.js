// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require('SupplyChain')
const truffleAssert = require('truffle-assertions');

contract('SupplyChain', function(accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    var cowID = 1;
    const ownerID = accounts[0]
    const originFarmerID = accounts[1]
    const originFarmName = "John Doe"
    const wholesalePrice = web3.utils.toWei("1", "ether")
    const retailPrice = web3.utils.toWei("2", "ether")
    var itemState = 0
    const processorID = accounts[2]
    const distributorID = accounts[3]
    const graderID = accounts[4]
    const retailerID = accounts[5]
    const consumerID = accounts[6]
    const emptyAddress = '0x00000000000000000000000000000000000000'

    ///Available Accounts
    ///==================
    ///(0) 0x27d8d15cbc94527cadf5ec14b69519ae23288b95
    ///(1) 0x018c2dabef4904ecbd7118350a0c54dbeae3549a
    ///(2) 0xce5144391b4ab80668965f2cc4f2cc102380ef0a
    ///(3) 0x460c31107dd048e34971e57da2f99f659add4f02
    ///(4) 0xd37b7b8c62be2fdde8daa9816483aebdbd356088
    ///(5) 0x27f184bdc0e7a931b507ddd689d76dba10514bcb
    ///(6) 0xfe0df793060c49edca5ac9c104dd8e3375349978
    ///(7) 0xbd58a85c96cc6727859d853086fe8560bc137632
    ///(8) 0xe07b5ee5f738b2f87f88b99aac9c64ff1e0c7917
    ///(9) 0xbd3ff2e3aded055244d66544c9c059fa0851da44

    console.log("ganache-cli accounts used here...")
    console.log("Contract Owner: accounts[0] ", accounts[0])
    console.log("Farmer: accounts[1] ", accounts[1])
    console.log("Processor: accounts[2] ", accounts[2])
    console.log("Distributor: accounts[3] ", accounts[3])
    console.log("Grader: accounts[4] ", accounts[4])
    console.log("Retailer: accounts[5] ", accounts[5])
    console.log("Consumer: accounts[6] ", accounts[6])

    //Assign roles
    async function addRoles(supplyChain) {
        supplyChain.addFarmer(originFarmerID);
        supplyChain.addProcessor(processorID);
        supplyChain.addDistributor(distributorID);
        supplyChain.addGrader(graderID);
        supplyChain.addRetailer(retailerID);
        supplyChain.addConsumer(consumerID);
    }

    // 1st Test
    it("Testing smart contract function raiseCow() that allows a farmer to raise a cow", async() => {
        const supplyChain = await SupplyChain.deployed()
        await addRoles(supplyChain);

        // Mark a cow as Raised by calling function raiseCow()
        var result = await supplyChain.raiseCow(cowID, originFarmName, {from: originFarmerID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], originFarmerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 1, 'Error: Invalid item State')
        truffleAssert.eventEmitted(result, 'Raised');
    })    

    // 2nd Test
    it("Testing smart contract function slaughterCow() that allows a processor to slaughter a cow", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Mark a cow as Slaugthered by calling function slaughterCow()
        var result = await supplyChain.slaughterCow(cowID, {from: processorID});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], originFarmerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 2, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        truffleAssert.eventEmitted(result, 'Slaughtered');
        
    })

    // 3rd Test
    it("Testing smart contract function splitCow() that allows a processor to split a cow", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Mark a cow as split by calling function splitCow()
        var result = await supplyChain.splitCow(cowID, {from: processorID});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], originFarmerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 3, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        truffleAssert.eventEmitted(result, 'Split');
    })   

    // 4th Test
    it("Testing smart contract function cleanCow() that allows a processor to clean a cow", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Mark a cow as Cleaned by calling function cleanCow()
        var result = await supplyChain.cleanCow(cowID, {from: processorID});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], originFarmerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 4, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        truffleAssert.eventEmitted(result, 'Cleaned');
    })
    
    // 5th Test
    it("Testing smart contract function gradeCow() that allows a grader to grade the meat quality", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Mark a cow as Graded by calling function gradeCow()
        var result = await supplyChain.gradeCow(cowID, {from: graderID});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], originFarmerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 5, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        assert.equal(resultBufferTwo[5], graderID, 'Error: Invalid grader ID')
        truffleAssert.eventEmitted(result, 'Graded');
    }) 

    // 6th Test
    it("Testing smart contract function sellWholesale() that allows a farmer to sell wholesale", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Mark an item as ForSaleWholesale by calling function sellWholesale()
        var result = await supplyChain.sellWholesale(cowID, wholesalePrice, {from: originFarmerID});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], originFarmerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 6, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        assert.equal(resultBufferTwo[5], graderID, 'Error: Invalid grader ID')
        assert.equal(resultBufferTwo[1], wholesalePrice, 'Error: Wrong wholesale price')
        truffleAssert.eventEmitted(result, 'ForSaleWholesale');  
    })    

    // 7th Test
    it("Testing smart contract function buyWholesale() that allows a distributor to buy wholesale", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Mark an item as Sold by calling function buyWholesale()
        var buyerStartingBalance = await web3.eth.getBalance(distributorID);
        var purchaseAmount = web3.utils.toWei("1.25", "ether");
        var gasCost = (await supplyChain.buyWholesale.estimateGas(cowID, {from: distributorID, value: purchaseAmount})) * (await web3.eth.getGasPrice());
        var buyerExpectedEndingBalance = buyerStartingBalance - wholesalePrice - gasCost;
        var result = await supplyChain.buyWholesale(cowID, {from: distributorID, value: purchaseAmount});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], distributorID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 7, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        assert.equal(resultBufferTwo[5], graderID, 'Error: Invalid grader ID')
        assert.equal(resultBufferTwo[6], distributorID, 'Error: Invalid distributor ID')
        assert.equal(resultBufferTwo[1], wholesalePrice, 'Error: Wrong wholesale price')
        truffleAssert.eventEmitted(result, 'BoughtWholesale');

        // Verify proper change was given
        var buyerActualEndingBalance = await web3.eth.getBalance(distributorID);
        var precision = 1000000000000000;
        
        // Estimated gas cost will be different from actual gas cost, so 'equal' in this case means within .001 ETH.
        assert.equal(Math.round((buyerExpectedEndingBalance - buyerActualEndingBalance) / precision), 0, 'Error: Distributor does not have expected ending balance');

    })    

    // 8th Test
    it("Testing smart contract function shipBeef() that allows a distributor to ship beef", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Mark an item as Shipped by calling function shipBeef()
        var result = await supplyChain.shipBeef(cowID, {from: distributorID});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], distributorID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 8, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        assert.equal(resultBufferTwo[5], graderID, 'Error: Invalid grader ID')
        assert.equal(resultBufferTwo[6], distributorID, 'Error: Invalid distributor ID')
        assert.equal(resultBufferTwo[1], wholesalePrice, 'Error: Wrong wholesale price')
        truffleAssert.eventEmitted(result, 'Shipped');
              
    })    

    // 9th Test
    it("Testing smart contract function sellRetail() that allows a retailer to sell beef", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Mark an item as ForSaleRetail by calling function sellRetail()
        var result = await supplyChain.sellRetail(cowID, retailPrice, {from: retailerID});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], retailerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 9, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        assert.equal(resultBufferTwo[5], graderID, 'Error: Invalid grader ID')
        assert.equal(resultBufferTwo[6], distributorID, 'Error: Invalid distributor ID')
        assert.equal(resultBufferTwo[7], retailerID, 'Error: Invalid retailer ID')
        assert.equal(resultBufferTwo[1], wholesalePrice, 'Error: Wrong wholesale price')
        assert.equal(resultBufferTwo[2], retailPrice, 'Error: Wrong retail price')
        truffleAssert.eventEmitted(result, 'ForSaleRetail');     
    })    

    // 10th Test
    it("Testing smart contract function buyRetail() that allows a consumer to purchase beef", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Mark an item as Purchased by calling function purchaseItem()
        var buyerStartingBalance = await web3.eth.getBalance(consumerID);
        var purchaseAmount = web3.utils.toWei("3", "ether");
        var gasCost = (await supplyChain.buyRetail.estimateGas(cowID, {from: consumerID, value: purchaseAmount})) * (await web3.eth.getGasPrice());
        var buyerExpectedEndingBalance = buyerStartingBalance - retailPrice - gasCost;
        var result = await supplyChain.buyRetail(cowID, {from: consumerID, value: purchaseAmount});

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)

        // Verify the result set
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], consumerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferTwo[3], 10, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        assert.equal(resultBufferTwo[5], graderID, 'Error: Invalid grader ID')
        assert.equal(resultBufferTwo[6], distributorID, 'Error: Invalid distributor ID')
        assert.equal(resultBufferTwo[7], retailerID, 'Error: Invalid retailer ID')
        assert.equal(resultBufferTwo[8], consumerID, 'Error: Invalid consumer ID')
        assert.equal(resultBufferTwo[1], wholesalePrice, 'Error: Wrong wholesale price')
        assert.equal(resultBufferTwo[2], retailPrice, 'Error: Wrong retail price')
        truffleAssert.eventEmitted(result, 'BoughtRetail');

        // Verify proper change was given
        var buyerActualEndingBalance = await web3.eth.getBalance(consumerID);
        var precision = 1000000000000000;

        // Estimated gas cost will be different from actual gas cost, so 'equal' in this case means within .001 ETH.
        assert.equal(Math.round((buyerExpectedEndingBalance - buyerActualEndingBalance) / precision), 0, 'Error: Consumer does not have expected ending balance');
    })    

    // 11th Test
    it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(cowID)
        
        // Verify the result set:
        assert.equal(resultBufferOne[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferOne[1], consumerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName')
    })

    // 12th Test
    it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(cowID)
        
        // Verify the result set:
        assert.equal(resultBufferTwo[0], cowID, 'Error: Invalid cowID')
        assert.equal(resultBufferTwo[1], wholesalePrice, 'Error: Wrong wholesale price')
        assert.equal(resultBufferTwo[2], retailPrice, 'Error: Wrong retail price')
        assert.equal(resultBufferTwo[3], 10, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[4], processorID, 'Error: Invalid processor ID')
        assert.equal(resultBufferTwo[5], graderID, 'Error: Invalid grader ID')
        assert.equal(resultBufferTwo[6], distributorID, 'Error: Invalid distributor ID')
        assert.equal(resultBufferTwo[7], retailerID, 'Error: Invalid retailer ID')
        assert.equal(resultBufferTwo[8], consumerID, 'Error: Invalid consumer ID')
    })
});

